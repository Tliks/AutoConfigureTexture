#pragma kernel CSMain

Texture2D<float4> _SrcTex;
int2 _TexSize;

uint _MipLevel;

uint _Window;

Texture2D<float> _IdTex;

RWStructuredBuffer<uint> _IslandSums;

RWStructuredBuffer<uint> _DebugZeroCounter;
RWStructuredBuffer<uint> _DebugNonZeroCounter;

static const float C1 = 0.01 * 0.01;
static const float C2 = 0.03 * 0.03;


float luminance(float3 c)
{
    return dot(c, float3(0.299, 0.587, 0.114));
}

uint SSIMToFixed(float ssim)
{
    ssim = clamp(ssim, 0.0, 1.0);
    return (uint)(ssim * 100.0);
}

float ComputeSSIM(int2 center)
{
    float sumX = 0.0, sumY = 0.0;
    float sumX2 = 0.0, sumY2 = 0.0, sumXY = 0.0;
    uint count = 0u;
    uint scale = (uint)(1 << max(0, _MipLevel));

    int halfWindow = _Window / 2;
    int centerY = center.y;
    int centerX = center.x;
    for (int dy = -halfWindow; dy <= halfWindow; dy++)
    {
        int yy = centerY + dy;
        if (yy < 0 || yy >= _TexSize.y) continue;
        uint yyL = (uint)yy / scale;
        for (int dx = -halfWindow; dx <= halfWindow; dx++)
        {
            int xx = centerX + dx;
            if (xx < 0 || xx >= _TexSize.x) continue;
            uint xxL = (uint)xx / scale;

            float3 a = _SrcTex.Load(int3(xx, yy, 0)).rgb;
            float3 b = _SrcTex.Load(int3(xxL, yyL, _MipLevel)).rgb;
            float lx = luminance(a);
            float ly = luminance(b);
            sumX += lx;
            sumY += ly;
            sumX2 += lx * lx;
            sumY2 += ly * ly;
            sumXY += lx * ly;
            count++;
        }
    }

    if (count == 0u) return 0.0; // Todo pixelが0のアイランドを適切に除外する？
    
    float invN = 1.0 / (float)count;
    float muX = sumX * invN;
    float muY = sumY * invN;
    float varX = sumX2 * invN - muX * muX;
    float varY = sumY2 * invN - muY * muY;
    float covXY = sumXY * invN - muX * muY;

    float ssim = ((2.0 * muX * muY + C1) * (2.0 * covXY + C2)) / ((muX * muX + muY * muY + C1) * (varX + varY + C2) + 1e-12);    
    return ssim;
}

void AccumulateResult(float ssim, int2 center)
{
    float idVal = _IdTex.Load(int3(center.x, center.y, 0));
    uint id = (uint)round(idVal);

    if (id == 0u)
    {
        InterlockedAdd(_DebugZeroCounter[0], 1u);
        return;
    }
    
    InterlockedAdd(_DebugNonZeroCounter[0], 1u);
    
    int bin = (int)id - 1;
    uint baseIndex = (uint)(bin * 2);

    uint deltaFixed = SSIMToFixed(ssim);
    InterlockedAdd(_IslandSums[baseIndex + 0], deltaFixed);
    InterlockedAdd(_IslandSums[baseIndex + 1], 1u);
}

[numthreads(8, 8, 1)]
void CSMain(uint2 center : SV_DispatchThreadID)
{
    if (center.x >= (uint)_TexSize.x || center.y >= (uint)_TexSize.y) return;
    
    float ssim = ComputeSSIM(center);
    if (ssim == 0.0) return;
    
    AccumulateResult(ssim, center);
}