#pragma kernel CSMain

// https://en.wikipedia.org/wiki/Structural_similarity_index_measure

Texture2D<float4> _SrcTex;
int2 _TexSize;

uint _MipLevel;

uint _Window;
float _alpha; // luminance 
float _beta; // contrast 
float _gamma; // structure 

Texture2D<float> _IdTex;
RWStructuredBuffer<uint> _IslandSums;

RWStructuredBuffer<uint> _DebugZeroCounter;
RWStructuredBuffer<uint> _DebugNonZeroCounter;

static const float L = 1.0;
static const float k_1 = 0.01;
static const float k_2 = 0.03;
static const float C1 = (k_1 * L) * (k_1 * L);
static const float C2 = (k_2 * L) * (k_2 * L);
static const float C3 = C2 * 0.5;

float luminance(float3 c)
{
    return dot(c, float3(0.299, 0.587, 0.114));
}

float ComputeSSIM(int2 center)
{
    float sumX = 0.0, sumY = 0.0;
    float sumX2 = 0.0, sumY2 = 0.0, sumXY = 0.0;
    uint count = 0u;
    uint scale = (uint)(1 << max(0, _MipLevel));

    int halfWindow = _Window / 2;
    int centerY = center.y;
    int centerX = center.x;
    for (int dy = -halfWindow; dy <= halfWindow; dy++)
    {
        int yy = centerY + dy;
        if (yy < 0 || yy >= _TexSize.y) continue;
        uint yyL = (uint)yy / scale;
        for (int dx = -halfWindow; dx <= halfWindow; dx++)
        {
            int xx = centerX + dx;
            if (xx < 0 || xx >= _TexSize.x) continue;
            uint xxL = (uint)xx / scale;

            float3 a = _SrcTex.Load(int3(xx, yy, 0)).rgb;
            float3 b = _SrcTex.Load(int3(xxL, yyL, _MipLevel)).rgb;
            float lx = luminance(a);
            float ly = luminance(b);
            sumX += lx;
            sumY += ly;
            sumX2 += lx * lx;
            sumY2 += ly * ly;
            sumXY += lx * ly;
            count++;
        }
    }

    if (count == 0u) return 0.0; // 最低でも中心のピクセルが条件を満たすはず
    
    float invN = 1.0 / (float)count;

    float muX = sumX * invN;
    float muY = sumY * invN;
    float varX = sumX2 * invN - muX * muX;
    float varY = sumY2 * invN - muY * muY;
    float covXY = sumXY * invN - muX * muY;

    varX = max(varX, 0.0);
    varY = max(varY, 0.0);

    float sigmaX = sqrt(varX);
    float sigmaY = sqrt(varY);
    
    float luminanceComponent = (2.0 * muX * muY + C1) / (muX * muX + muY * muY + C1);
    float contrastComponent = (2.0 * sigmaX * sigmaY + C2) / (varX + varY + C2);
    float structureComponent = (covXY + C3) / (sigmaX * sigmaY + C3);
    
    float ssim = pow(luminanceComponent, _alpha) * pow(contrastComponent, _beta) * pow(structureComponent, _gamma);
    
    return ssim;
}

uint SSIMToFixed(float ssim)
{
    ssim = clamp(ssim, 0.0, 1.0);
    return (uint)(ssim * 100.0);
}

void AccumulateResult(float ssim, int2 center)
{
    float idVal = _IdTex.Load(int3(center.x, center.y, 0));
    uint id = (uint)round(idVal);

    if (id == 0u)
    {
        InterlockedAdd(_DebugZeroCounter[0], 1u);
        return;
    }
    
    InterlockedAdd(_DebugNonZeroCounter[0], 1u);
    
    int bin = (int)id - 1;
    uint baseIndex = (uint)(bin * 2);

    uint deltaFixed = SSIMToFixed(ssim);
    InterlockedAdd(_IslandSums[baseIndex + 0], deltaFixed);
    InterlockedAdd(_IslandSums[baseIndex + 1], 1u);
}

[numthreads(8, 8, 1)]
void CSMain(uint2 center : SV_DispatchThreadID)
{
    if (center.x >= (uint)_TexSize.x || center.y >= (uint)_TexSize.y) return;
    
    float ssim = ComputeSSIM(center);
    if (ssim == 0.0) return;
    
    AccumulateResult(ssim, center);
}